# ブラウザとその仕組み

早いWebサイトはよりより用意ユーザ体験を提供する。
Webのパフォーマンスに関すうる主な要因は、「レイテンシ」に関する問題と「Webブラウザ」が単一スレッド実行されていることに起因している。

レイテンシはコンピュータにバイト列を送信するのにかかる時間のことをいう。
Webパフォーマンスを改善するためには、ユーザからリクエストのあったWebページを可能な限り早く提供することが開発者の目標になる。

多くブラウザはシングルスレッド動作しているため
一つの処理が終わった後に次の処理を開始する。
そのため、メインスレッドの責務を最小限に押さえて、描画のスムーズさと操作に対して即時に反応するようにすることで、パフォーマンスが改善される。

## ナビゲーション

ナビゲーションはWebページを読み込むための最初に行われる。
ナビゲーションは、URLをアドレスバーに入力したり、リンクをクリックしたり、フォームを送信したりページをリクエストするたびに発生する。
パフォーマンスにおける目標の一つは、ナビゲーションが完了するまでの時間を最小限にすこと。

### DNS検索

ブラウザがDNS検索ををリクエストし、ネームサーバによって処理されてネームサーバからIPアドレスがレスポンスとして返される。
ドメインのIPアドレスはしばらくの間キャッシュされ、ネームサーバに再接続する代わりにキャッシュからIPアドレスを取得することで、皇族のリクエストの速度を向上することができる。
DNS検査は1回のページの読み込み中にホスト名ごとに1回行われる。
DNS検査は要求されたページが参照するユニークなホスト名に対して、それぞれに実行する必要がある。
そのため、ページ内のリソースが異なるホスト名を持っている場合は、それぞれに対してDNS検索を行う必要がある。

### TCPハンドシェイク

IPアドレスが判明するとブラウザは、TCP3ウェイハンドシェイクを通じてサーバとのコネクションを設定を行う。
クライアントとサーバがデータを送信する前に、HTTPSもしくはHTTPを用いてTCPソケットコネクションのパラメータを交換できるように設計されている。

3ウェイハンドシェイクでは、`SYNC, SYNC-ACK, ACK`と呼ばれる3つのメッセージの送受信が行われる。

### TLSネゴシェーション

HTTPSによって安全に確立されるコネクションの場合3ウェイハンドシェイクに加えて、もう一つハンドシェイクが必要になる。
TLSネゴシエーションでは、通信の暗号化に使用する暗号を決定し、サーバを認証し実際にデータの送信が始まる前に安全な通信の準備を整える。
3ウェイハンドシェイクに加えて5回のラウンドトリップが行われ、計8回のラウンドトリップを経てクライアントはサーバにリクエストを送ることになる。

## レスポンス

サーバにコネクションが確立されると、ブラウザはHTTP GETリクエストを行う。
リクエストを受け取ったサーバは、レスポンスヘッダー、リクエストされたコンテンツをレスポンスとして返す。
レスポンスには受信データの最初のバイトを含んでいる。
TTFB(Tome to First Byte)は、リンクをクリックしてから最初のパケットを受け取るまでにかかった時間を表している。

### 輻輳制御 / TCP スロースタート

TCPパケット送信中にセグメントに分割される。TCPパケットの順序は保証されるため一定数のセグメントを送信した後にクライアントから、ACKパケット(受信に成功したというパケット)とういう形で応答を受け取らなければならない。

セグメントが終わるたびにサーバが、クライアントからのACKを送信を待つと低負荷のネットワークであっても送信時間が長くなる可能性がある。
逆にサーバがセグメントを送信し続けると、クライアントがセグメントを受信できずサーバにACKパケットを送信することができない。その結果、サーバはセグメントを不必要に再送しなければいけなくなる。

## 構文解析

クリティカルレンダリングパスという、ブラウザがHTML, CSS, JavaScriptを画面上のピクセル変換すための最初のステップ。

ネットワークから受信したデータをDOMとCSSOMに変換するステップ。
DOMはブラウザ向けのマークアップの内部的な表現。
DOMは外部に公開されておりJavaScriptのさまざまなAPIを通じて操作することができる。

### DOMツリーの構築

HTMLのマークアップを処理してDOMツリーを構築する。
HTMLの構文解析はトークン化とツリーの構築に別れる。

HTMLの開始タグと終了タグ, 属性の名前と値を解析する。HTMLが正しく記述されていれば、構文解析は高速に行われる。
パーサーは、トークン化された入力情報からツリーを構成する文章に変換する。

DOMツリーは`<html>`タグで始まる親子関係を持つ階層構造で構成される。
DOMのノード数が増えるほどDOMツリーの構築にかかる時間は長くなる。
パーサーがCSSファイルなどのノンブロッキングリソースを発見した場合は、構文解析を継続するが`<script>`タグのように`async`もしくは、`defer`属性の持たない要素はHTMLの構文解析を停止してしまう。
ブラウザの事前読み込みスキャナーはブロック時間を減らしてくれるが、ブロッキング要素を多用すると重大なボトルネックにつながってしまう。

#### 事前読み込みスキャナー

事前読み込みスキャナーによってブロッキングを減らすことができる。

ブラウザがDOMツリーを構築する間はそのプロセスがメインスレッドを選集する。その間に事前読み込みスキャナが処理可能なコンテンツを解釈し、CSSやJavaScript, ウェブフォントのような優先度の高いリソースへのリクエストを行う。
事前読み込みスキャナーのおかげでパーサがメインのHTMLのアセットにたどり着いた時には、リソースが転送中もしくは、ダウンロード済みになっている。

### CSSOMの構築

クリティカルレンダリングパスの次のステップでは、CSSOMの構築を行う。
ブラウザは受信したCSSファイルをHTMLファイル同様、CSSをブラウザで実行可能な形式に変換する処理を行う。
CSSOMはユーザーエージェントのスタイルシートから取得したスタイルの変換も行う。
CSSOMの構築は、1回のDNS検索にかかる時間よりも少ないためあまり気にする必要はない。

### その他の処理

#### JavaScriptコンパイル

JavaScriptは構文解析されたのちにコンパイルされて解釈される。
ブラウザエンジンからコンパイラーへ引き渡され、メインスレッド実行されるバイトコードを出力する。
ほんとんどのコードはメインスレッドで動作するが、ウェブワーカーで実行するコードなどの例外も存在する。

#### アクセシビリティツリーの構築

アクセシビリティツリーの構築も行う。
AOMが構築されるまでスクリーリーダーでコンテンツにアクセスすることができない。

## レンダリング

レンダリングのステップでは、スタイル, レイアウト, 描画, 合成で構成される。
DOMとCSSOMは、レンダリングツリーの形式へと組み合わせれて、ビジュアル要素のレイアウトを計算されて画面へ描写が行われる。

### スタイル

クリティカルレンダリングパスの3番目のステップ。
DOMとCSSOMをレンダーツリーの形式へと組み合わせるステップ。
DOMツリーのルートからスタートして、目に見えるノードを走査する。

`<head>`要素のような画面に表示されない要素とその子要素はレンダリングの結果に影響しないため、レンダーツリーに含まれない。
レンダリングされるノードはCSSOMのルールが適用される。
レンダーツリーは、すべてのレンダリングされるノードとコンテンンツと計算されたスタイルを合わせて保持し、関連するスタイルとDOM上のノードをマッチングしCSSカスケードに基づいて計算されたスタイルを決定する。

### レイアウト

クリティカルレンダリングパスの4番目のステップ。
書くノードの平面上の位置を計算するためにレイアウトの処理を実行するステップ。
レンダーツリーが構築されるとすぐにレイアウトが始まる。
レンダーツリーは計算あｓれたスタイルｔを踏まえてどのノードが表示されるか特定する。
サイズや位置の特定は行わないため、各オブジェクトの正確な寸法と位置を決めるためにブラウザーがレンダーツリーのルートから走査を行う。

この段階でビューポートの寸法を考慮してすべての要素の寸法を決定する。
レイアウトはすべてのbodyの子孫をそれぞれの要素のボックスモデルプロパティに合わせてレイアウトを行い、画像のような寸法のわからない代替要素のためにプレースホルダースペースを作成する。

ノードの寸法と位置が決められる瞬間をレイアウトと呼び、ノードの寸法と位置の再計算を再フローと呼ぶ。
例えばがぞが返される前にレイアウトが発生したタイミングでは、画像のサイズは宣言されていないため、画像のサイズがわかるとサイフロが発生する。

### 描画

クリティカルレンダリングパスの最後のステップ。
個別のノードを画面に描画するステップ。
ブラウザーはレイアウトのファン会で計算された、ボックスを画面上のピクセルに変換する。
描画は、テキスト, 色, ボーダー, シャドウ, 画像のようなさまざまな要素の視覚的に表示される部分を画面に表示する。

描画は描画ツリー内の要素をレイヤーに分解する。
コンテンツをGPU上のレイヤーに昇格させることで、描画と再描画のパフォーマンスを向上させる。
レイヤーはパフォーマンスを改善することができるが、メモリー管理の面でコストがかかる処理であるため、パフォーマンス最適化をする中で乱用するべきではない。

### 合成

文章のセクションが異なるレイヤーに描画されていて、それらが重なりあっている時にコンテンツを画面上に正しい順番で描画する必要がある。

ページのアセットを読み込んでいる間にも再フローが発生する。
竿フローは再描画と再合成を引き起こす。
もし、画像にサイズを指定していた場合は再フローの必要がなくなり、再描画が必要なレイヤーのみが再描画が行われる。

### 操作可能性

メインスレッドでページの描画が完了したら`onload`イベントの発行によってJavaScriptが実行される場合がある。
その場合メインスレッドがビジー状態になりスクロールやタッチなどの操作ができない場合がある。

TTI(Time to Interactive)というDNS検索とTCP接続を始めるリクエストからページが操作可能になるまでどのくらいの時間がかかったかを示す測定値がある。
この時の操作可能とは、FCP(First Contentful Paint)の後の時点のことを指す。(ページがレンダリングされ始めるまでの時間)
メインスレッドが構文解析, コンパイル, Javascriptの実行に専有されている場合はユーザの操作にタイムリーに応答することができない。
